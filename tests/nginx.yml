# SPDX-License-Identifier: MIT-0
---
- name: Test Nginx Ingress Controller Installation
  hosts: kubernetes_nodes
  gather_facts: true
  become: false
  vars:
    # Nginx ingress configuration using new structure
    nginx_ingress_kubeconfig:
      # Use default kubeconfig location on target node
      path: ""

    nginx_ingress_helm:
      wait: true
      timeout: "15m"
      force: false
    
    # Override service type if needed (default is already NodePort)
    # nginx_ingress_values:
    #   controller:
    #     service:
    #       type: "LoadBalancer"  # Example override

  pre_tasks:
    - name: Display target node information
      ansible.builtin.debug:
        msg: |
          Target Node Information:
          - Hostname: {{ inventory_hostname }}
          - IP Address: {{ ansible_host }}
          - User: {{ ansible_user }}
          - Python Interpreter: {{ ansible_python_interpreter }}

    - name: Check if target node is reachable
      ansible.builtin.ping:

    - name: Gather system information
      ansible.builtin.setup:
        gather_subset:
          - "!all"
          - "!min"
          - "system"
          - "network"

    - name: Display system information
      ansible.builtin.debug:
        msg: |
          System Information:
          - OS: {{ ansible_distribution }} {{ ansible_distribution_version }}
          - Architecture: {{ ansible_architecture }}
          - Kernel: {{ ansible_kernel }}
          - Hostname: {{ ansible_hostname }}

    - name: Check if kubeconfig exists
      ansible.builtin.stat:
        path: "{{ ansible_env.HOME }}/.kube/config"
      register: kubeconfig_check

    - name: Display kubeconfig status
      ansible.builtin.debug:
        msg: |
          Kubeconfig Status:
          - Path: {{ ansible_env.HOME }}/.kube/config
          - Exists: {{ kubeconfig_check.stat.exists }}
          - Size: {{ kubeconfig_check.stat.size | default('N/A') }} bytes
          - Owner: {{ kubeconfig_check.stat.pw_name | default('N/A') }}

    - name: Fail if kubeconfig doesn't exist
      ansible.builtin.fail:
        msg: "Kubeconfig file not found at {{ ansible_env.HOME }}/.kube/config. Please ensure kubectl is configured on the target node."
      when: not kubeconfig_check.stat.exists

    - name: Test kubectl connectivity
      ansible.builtin.command:
        cmd: kubectl cluster-info
      register: kubectl_test
      changed_when: false
      failed_when: kubectl_test.rc != 0

    - name: Display cluster information
      ansible.builtin.debug:
        msg: |
          Kubernetes Cluster Info:
          {{ kubectl_test.stdout }}

  roles:
    - padminisys.nginx_ingress.nginx

  post_tasks:
    # Check if kubernetes Python library is available for k8s_info modules
    - name: Check if kubernetes Python library is available
      ansible.builtin.command:
        cmd: "{{ ansible_python_interpreter }} -c 'import kubernetes; print(kubernetes.__version__)'"
      register: k8s_lib_check
      changed_when: false
      failed_when: false

    - name: Display kubernetes library status
      ansible.builtin.debug:
        msg: |
          üêç Python Kubernetes Library Status:
          - Available: {{ k8s_lib_check.rc == 0 }}
          {% if k8s_lib_check.rc == 0 %}
          - Version: {{ k8s_lib_check.stdout }}
          {% else %}
          - Error: {{ k8s_lib_check.stderr | default('Library not found') }}
          {% endif %}

    # Use kubectl-based validation when kubernetes library is not available
    - name: Wait for nginx ingress controller deployment (kubectl method)
      ansible.builtin.command:
        cmd: >-
          kubectl wait --for=condition=available --timeout=300s
          deployment/{{ nginx_ingress_release.name }}-controller
          -n {{ nginx_ingress_release.namespace }}
      register: deployment_wait
      changed_when: false
      when: k8s_lib_check.rc != 0

    - name: Get deployment status using kubectl
      ansible.builtin.command:
        cmd: >-
          kubectl get deployment {{ nginx_ingress_release.name }}-controller
          -n {{ nginx_ingress_release.namespace }} -o json
      register: deployment_kubectl
      changed_when: false
      when: k8s_lib_check.rc != 0

    - name: Get pods using kubectl
      ansible.builtin.command:
        cmd: >-
          kubectl get pods -n {{ nginx_ingress_release.namespace }}
          -l app.kubernetes.io/name=ingress-nginx,app.kubernetes.io/component=controller
          -o json
      register: pods_kubectl
      changed_when: false
      when: k8s_lib_check.rc != 0

    - name: Get service using kubectl
      ansible.builtin.command:
        cmd: >-
          kubectl get service {{ nginx_ingress_release.name }}-controller
          -n {{ nginx_ingress_release.namespace }} -o json
      register: service_kubectl
      changed_when: false
      when: k8s_lib_check.rc != 0

    # Use kubernetes.core modules when library is available
    - name: Wait for nginx ingress controller deployment to be ready (k8s_info method)
      kubernetes.core.k8s_info:
        api_version: apps/v1
        kind: Deployment
        name: "{{ nginx_ingress_release.name }}-controller"
        namespace: "{{ nginx_ingress_release.namespace }}"
        kubeconfig: "{{ ansible_env.HOME }}/.kube/config"
        wait: true
        wait_condition:
          type: Available
          status: "True"
        wait_timeout: 300
      register: deployment_status
      when: k8s_lib_check.rc == 0

    - name: Get nginx ingress controller pods (k8s_info method)
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Pod
        namespace: "{{ nginx_ingress_release.namespace }}"
        label_selectors:
          - "app.kubernetes.io/name=ingress-nginx"
          - "app.kubernetes.io/component=controller"
        kubeconfig: "{{ ansible_env.HOME }}/.kube/config"
      register: nginx_pods
      when: k8s_lib_check.rc == 0

    - name: Get nginx ingress controller service (k8s_info method)
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Service
        name: "{{ nginx_ingress_release.name }}-controller"
        namespace: "{{ nginx_ingress_release.namespace }}"
        kubeconfig: "{{ ansible_env.HOME }}/.kube/config"
      register: nginx_service
      when: k8s_lib_check.rc == 0

    # Parse kubectl JSON output for display
    - name: Parse kubectl deployment output
      ansible.builtin.set_fact:
        deployment_info: "{{ deployment_kubectl.stdout | from_json }}"
      when: k8s_lib_check.rc != 0

    - name: Parse kubectl pods output
      ansible.builtin.set_fact:
        pods_info: "{{ pods_kubectl.stdout | from_json }}"
      when: k8s_lib_check.rc != 0

    - name: Parse kubectl service output
      ansible.builtin.set_fact:
        service_info: "{{ service_kubectl.stdout | from_json }}"
      when: k8s_lib_check.rc != 0

    # Display results (kubectl method)
    - name: Display installation results (kubectl method)
      ansible.builtin.debug:
        msg: |
          üéâ Nginx Ingress Controller Installation Complete!

          üìä Deployment Status:
          - Name: {{ deployment_info.metadata.name }}
          - Namespace: {{ deployment_info.metadata.namespace }}
          - Ready Replicas: {{ deployment_info.status.readyReplicas | default(0) }}
          - Available Replicas: {{ deployment_info.status.availableReplicas | default(0) }}

          üöÄ Running Pods:
          {% for pod in pods_info.items %}
          - {{ pod.metadata.name }}: {{ pod.status.phase }}
          {% endfor %}

          üåê Service Details:
          - Name: {{ service_info.metadata.name }}
          - Type: {{ service_info.spec.type }}
          - Cluster IP: {{ service_info.spec.clusterIP }}
          {% if service_info.spec.type == 'NodePort' %}
          - NodePorts:
          {% for port in service_info.spec.ports %}
            - {{ port.name }}: {{ port.port }}:{{ port.nodePort }}/{{ port.protocol }}
          {% endfor %}
          {% endif %}

          ‚úÖ Access URLs ({{ nginx_ingress_values.controller.service.type }}):
          {% if nginx_ingress_values.controller.service.type == 'NodePort' %}
          - HTTP: http://{{ ansible_host }}:{{ service_info.spec.ports | selectattr('name', 'equalto', 'http') | map(attribute='nodePort') | first }}
          - HTTPS: https://{{ ansible_host }}:{{ service_info.spec.ports | selectattr('name', 'equalto', 'https') | map(attribute='nodePort') | first }}
          {% elif nginx_ingress_values.controller.service.type == 'LoadBalancer' %}
          - HTTP: http://{{ service_info.status.loadBalancer.ingress[0].ip | default('PENDING') }}
          - HTTPS: https://{{ service_info.status.loadBalancer.ingress[0].ip | default('PENDING') }}
          {% else %}
          - Cluster IP: {{ service_info.spec.clusterIP }}
          {% endif %}
      when: k8s_lib_check.rc != 0

    # Display results (k8s_info method)
    - name: Display installation results (k8s_info method)
      ansible.builtin.debug:
        msg: |
          üéâ Nginx Ingress Controller Installation Complete!

          üìä Deployment Status:
          - Name: {{ deployment_status.resources[0].metadata.name }}
          - Namespace: {{ deployment_status.resources[0].metadata.namespace }}
          - Ready Replicas: {{ deployment_status.resources[0].status.readyReplicas | default(0) }}
          - Available Replicas: {{ deployment_status.resources[0].status.availableReplicas | default(0) }}

          üöÄ Running Pods:
          {% for pod in nginx_pods.resources %}
          - {{ pod.metadata.name }}: {{ pod.status.phase }}
          {% endfor %}

          üåê Service Details:
          - Name: {{ nginx_service.resources[0].metadata.name }}
          - Type: {{ nginx_service.resources[0].spec.type }}
          - Cluster IP: {{ nginx_service.resources[0].spec.clusterIP }}
          {% if nginx_service.resources[0].spec.type == 'NodePort' %}
          - NodePorts:
          {% for port in nginx_service.resources[0].spec.ports %}
            - {{ port.name }}: {{ port.port }}:{{ port.nodePort }}/{{ port.protocol }}
          {% endfor %}
          {% endif %}

          ‚úÖ Access URLs ({{ nginx_ingress_values.controller.service.type }}):
          {% if nginx_ingress_values.controller.service.type == 'NodePort' %}
          - HTTP: http://{{ ansible_host }}:{{ nginx_service.resources[0].spec.ports | selectattr('name', 'equalto', 'http') | map(attribute='nodePort') | first }}
          - HTTPS: https://{{ ansible_host }}:{{ nginx_service.resources[0].spec.ports | selectattr('name', 'equalto', 'https') | map(attribute='nodePort') | first }}
          {% elif nginx_ingress_values.controller.service.type == 'LoadBalancer' %}
          - HTTP: http://{{ nginx_service.resources[0].status.loadBalancer.ingress[0].ip | default('PENDING') }}
          - HTTPS: https://{{ nginx_service.resources[0].status.loadBalancer.ingress[0].ip | default('PENDING') }}
          {% else %}
          - Cluster IP: {{ nginx_service.resources[0].spec.clusterIP }}
          {% endif %}
      when: k8s_lib_check.rc == 0

    # Health check (works for both methods)
    - name: Get NodePort for health check (kubectl method)
      ansible.builtin.set_fact:
        http_nodeport: "{{ service_info.spec.ports | selectattr('name', 'equalto', 'http') | map(attribute='nodePort') | first }}"
      when: k8s_lib_check.rc != 0 and nginx_ingress_values.controller.service.type == 'NodePort'

    - name: Get NodePort for health check (k8s_info method)
      ansible.builtin.set_fact:
        http_nodeport: "{{ nginx_service.resources[0].spec.ports | selectattr('name', 'equalto', 'http') | map(attribute='nodePort') | first }}"
      when: k8s_lib_check.rc == 0 and nginx_ingress_values.controller.service.type == 'NodePort'

    - name: Test nginx ingress controller health
      ansible.builtin.uri:
        url: "http://{{ ansible_host }}:{{ http_nodeport }}/healthz"
        method: GET
        status_code: 200
      register: health_check
      ignore_errors: true
      when: nginx_ingress_values.controller.service.type == 'NodePort' and http_nodeport is defined

    - name: Display health check result
      ansible.builtin.debug:
        msg: |
          üè• Health Check:
          - Status: {{ 'HEALTHY' if health_check.status == 200 else 'UNHEALTHY' }}
          - Response Code: {{ health_check.status | default('N/A') }}
          - URL: http://{{ ansible_host }}:{{ http_nodeport }}/healthz
      when: health_check is defined